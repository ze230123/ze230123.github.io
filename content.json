{"meta":{"title":"泽i blog","subtitle":null,"description":null,"author":"泽i","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-10-19T10:52:27.000Z","updated":"2017-10-19T10:53:47.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-19T10:54:05.000Z","updated":"2017-10-19T10:54:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift获取通讯录信息","slug":"Contacts","date":"2018-01-12T09:38:56.000Z","updated":"2018-01-12T10:34:36.274Z","comments":true,"path":"2018/01/12/Contacts/","link":"","permalink":"http://yoursite.com/2018/01/12/Contacts/","excerpt":"","text":"在iOS 9之后通过 Contacts FrameWork 获取通讯录信息，AddressBook framework被废弃。 Contacts FrameWork包含两种获取通讯录方式 ContactsUI: 通过系统提供的通讯录交互界面来访问 Contacts: 没有界面，通过代码来获取所有联系人信息 本文介绍Contacts使用 一、Contacts介绍 Contacts使用步骤 获取用户授权，如果授权继续下面的步骤 创建通讯录对象 创建请求对象 遍历获取的联系人对象 联系人记录的属性 每条联系人记录的属性分为单值属性和多值属性 单值属性是只有一个值的属性: familyName ：姓 givenName ：名 middleName ：中间名 previousFamilyName ：前缀 nameSuffix ：后缀 phoneticFamilyName ：姓氏汉语拼音或音标 phoneticGivenName ：名字汉语拼音或音标 nickname ：昵称 organizationName ：公司（组织） jobTitle ：职位 departmentName ：部门 note ：备注 多值属性是包含多个值的集合类型： phoneNumbers ：电话 emailAddresses ：Email postalAddresses ：地址 urlAddresses ：URL属性 dates ：纪念日 instantMessageAddresses ：获取即时通讯(IM) socialProfiles ：社交账号 contactRelations ：亲属关系人 多值属性标签的本地名称 在多值属性中包含了 label（标签）、value（值）和 ID 等部分，其中标签和值都是可以重复的，而 ID 是不能重复的。对于标签，我们可以使用 CNLabeledValue.localizedString(forLabel:) 方法转为本地标签名（即能看得懂的标签名，比如 work、home）。要不然打印出来的是 _$!&lt;Home&gt;!$_，_$!&lt;Work&gt;!$_ 这样的数据。 二、获取联系人不要忘记在info.plist中添加Privacy - Contacts Usage Description 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import UIKitimport Contactsclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() CNContactStore().requestAccess(for: .contacts) &#123; (isRight, error) in if isRight &#123; self.loadContactsData() &#125; &#125; &#125; func loadContactsData() &#123; // 获取授权状态 let status = CNContactStore.authorizationStatus(for: .contacts) // 判断当前状态 guard status == .authorized else &#123; return &#125; // 获取通讯录对象 let store = CNContactStore() //获取Fetch,并且指定要获取联系人中的什么属性 let keys = [CNContactFamilyNameKey, CNContactGivenNameKey, CNContactNicknameKey, CNContactOrganizationNameKey, CNContactJobTitleKey, CNContactDepartmentNameKey, CNContactNoteKey, CNContactPhoneNumbersKey, CNContactEmailAddressesKey, CNContactPostalAddressesKey, CNContactDatesKey, CNContactInstantMessageAddressesKey ] //创建请求对象 //需要传入一个(keysToFetch: [CNKeyDescriptor]) 包含CNKeyDescriptor类型的数组 let request = CNContactFetchRequest(keysToFetch: keys as [CNKeyDescriptor]) do &#123; try store.enumerateContacts(with: request, usingBlock: &#123; (contact, _) in //获取姓名 let lastName = contact.familyName let firstName = contact.givenName print(\"\\(lastName)\\(firstName)\") //获取昵称 let nikeName = contact.nickname print(\"昵称：\\(nikeName)\") //获取公司（组织） let organization = contact.organizationName print(\"公司（组织）：\\(organization)\") //获取职位 let jobTitle = contact.jobTitle print(\"职位：\\(jobTitle)\") //获取部门 let department = contact.departmentName print(\"部门：\\(department)\") //获取备注 let note = contact.note print(\"备注：\\(note)\") //获取电话号码 print(\"电话：\") for phone in contact.phoneNumbers &#123; //获得标签名（转为能看得懂的本地标签名，比如work、home） var label = \"未知标签\" if phone.label != nil &#123; label = CNLabeledValue&lt;NSString&gt;.localizedString(forLabel: phone.label!) &#125; //获取号码 let value = phone.value.stringValue print(\"\\t\\(label)：\\(value)\") &#125; //获取Email print(\"Email：\") for email in contact.emailAddresses &#123; //获得标签名（转为能看得懂的本地标签名） var label = \"未知标签\" if email.label != nil &#123; label = CNLabeledValue&lt;NSString&gt;.localizedString(forLabel: email.label!) &#125; //获取值 let value = email.value print(\"\\t\\(label)：\\(value)\") &#125; //获取地址 print(\"地址：\") for address in contact.postalAddresses &#123; //获得标签名（转为能看得懂的本地标签名） var label = \"未知标签\" if address.label != nil &#123; label = CNLabeledValue&lt;NSString&gt;.localizedString(forLabel: address.label!) &#125; //获取值 let detail = address.value let contry = detail.value(forKey: CNPostalAddressCountryKey) ?? \"\" let state = detail.value(forKey: CNPostalAddressStateKey) ?? \"\" let city = detail.value(forKey: CNPostalAddressCityKey) ?? \"\" let street = detail.value(forKey: CNPostalAddressStreetKey) ?? \"\" let code = detail.value(forKey: CNPostalAddressPostalCodeKey) ?? \"\" let str = \"国家:\\(contry) 省:\\(state) 城市:\\(city) 街道:\\(street)\" + \" 邮编:\\(code)\" print(\"\\t\\(label)：\\(str)\") &#125; //获取纪念日 print(\"纪念日：\") for date in contact.dates &#123; //获得标签名（转为能看得懂的本地标签名） var label = \"未知标签\" if date.label != nil &#123; label = CNLabeledValue&lt;NSString&gt;.localizedString(forLabel: date.label!) &#125; //获取值 let dateComponents = date.value as DateComponents let value = NSCalendar.current.date(from: dateComponents) let dateFormatter = DateFormatter() dateFormatter.dateFormat = \"yyyy年MM月dd日 HH:mm:ss\" print(\"\\t\\(label)：\\(dateFormatter.string(from: value!))\") &#125; //获取即时通讯(IM) print(\"即时通讯(IM)：\") for im in contact.instantMessageAddresses &#123; //获得标签名（转为能看得懂的本地标签名） var label = \"未知标签\" if im.label != nil &#123; label = CNLabeledValue&lt;NSString&gt;.localizedString(forLabel: im.label!) &#125; //获取值 let detail = im.value let username = detail.value(forKey: CNInstantMessageAddressUsernameKey) ?? \"\" let service = detail.value(forKey: CNInstantMessageAddressServiceKey) ?? \"\" print(\"\\t\\(label)：\\(username) 服务:\\(service)\") &#125; print(\"----------------\") &#125;) &#125; catch &#123; print(error) &#125; &#125;&#125; 示例代码下载","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"}]},{"title":"nginx安装、启动、退出","slug":"nginx","date":"2018-01-12T09:10:09.000Z","updated":"2018-01-12T09:12:06.134Z","comments":true,"path":"2018/01/12/nginx/","link":"","permalink":"http://yoursite.com/2018/01/12/nginx/","excerpt":"","text":"nginx 安装 brew install nginx sudo nginx // 启动sudo nginx -s stop/quit/reopen/reload //发送信号给主进程：停止，退出，重新打开，重新加载","categories":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/categories/nginx/"}],"tags":[{"name":"nginx命令","slug":"nginx命令","permalink":"http://yoursite.com/tags/nginx命令/"}]},{"title":"制作一个类似游标卡尺的视图","slug":"rulerView","date":"2018-01-12T04:18:25.000Z","updated":"2018-01-12T08:49:07.925Z","comments":true,"path":"2018/01/12/rulerView/","link":"","permalink":"http://yoursite.com/2018/01/12/rulerView/","excerpt":"","text":"项目需要用到类似游标卡尺的控件来选择金额，效果如下： 效果图 需求分析 控件有一个卡尺刻度的视图，可以左右滑动，选中的刻度始终位于控件的x轴中心。 卡尺刻度在0、5的倍数位置的刻度为长线，其余为短线，可以设置最大的刻度、每格等于的值。 控件的x轴中心有一条竖线，表示当前选中的刻度。 刻度的上方有一个label实时显示当前处于x轴中心线位置的刻度所代表的数值。 卡尺刻度选用UICollectionView来实现 实现思路控件比较有难度的是刻度部分，在此重点说一下刻度的实现，刻度是用UICollectionView实现的，根据最大值计算有多少个Cell，在每个Cellx轴中心画一条竖线，通过layout的sectionInset属性实现0、和最大值的位置处于x轴中心线。 123let layout = UICollectionViewFlowLayout() let margin = (frame.width - itemWidth) / 2layout.sectionInset = UIEdgeInsets(top: 0, left: margin, bottom: 0, right: margin) 根据设置的最大值，和每个刻度的值计算Item的数量，并填充Cell的数据 1234567891011121314151617181920// MARK: - UICollectionViewDataSourceextension Ruler: UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return itemCount &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; var cell: UICollectionViewCell //0和5的倍数是长线的Cell switch indexPath.item % 5 &#123; case 0: cell = collectionView.dequeueReusableCell(withReuseIdentifier: longCellId, for: indexPath) (cell as? LongLineCell)?.textLabel.text = \"\\(indexPath.item * textRatio)\\(textUnit)\" default: cell = collectionView.dequeueReusableCell(withReuseIdentifier: shortCellId, for: indexPath) &#125; return cell &#125;&#125; 此时已经实现了刻度，但是此时左右滑动后刻度不会停止在x轴中心线的位置，还需要我们实现delegate的方法去自行设置刻度停止位置 12345678910111213141516171819202122232425262728293031// MARK: - UIScrollViewDelegateextension Ruler: UIScrollViewDelegate &#123; func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) &#123; // 手指离开屏幕后，CollectionView将要停下的位置，换算成整数确保停留在中间线上 let index = round(targetContentOffset.pointee.x / itemWidth) targetContentOffset.pointee.x = index * itemWidth &#125; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; // 实时显示金额 let index = round(scrollView.contentOffset.x / itemWidth) rulerView?.set(current: Int(index) * textRatio) &#125; // 停下后通知代理当前选中的金额 func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; delegate?.ruler(self, currentPrice: calculatePrice(scrollView)) &#125; func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; // 如果停在了边界，decelerate为false时通知代理 // 此处是处理刻度已经滑动到0或者最大值时不松开手机继续滑动后，当手指松开后不会走上方的代理方法，导致不会发送消息的delegate guard !decelerate else &#123; return &#125; delegate?.ruler(self, currentPrice: calculatePrice(scrollView)) &#125; // 代码滚动 func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) &#123; delegate?.ruler(self, currentPrice: calculatePrice(scrollView)) &#125;&#125; 其余的实现都很简单就不多写了 点击获取代码","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"http://yoursite.com/tags/自定义控件/"}]},{"title":"Idkeyboard-自定义身份证号码键盘","slug":"Idkeyboard","date":"2017-10-20T07:19:30.000Z","updated":"2017-10-20T09:49:16.000Z","comments":true,"path":"2017/10/20/Idkeyboard/","link":"","permalink":"http://yoursite.com/2017/10/20/Idkeyboard/","excerpt":"","text":"项目中需要输入身份证号，系统自带的键盘用来输入很不方便，所以就需要自定做一个带X的数字键盘。 现在网上有很多都是通过循环创建button，在计算其frame。前几天看到了UIStackView，其可以使多个View按照横向或竖向对齐排列，就用stackView写了一个键盘。 效果如下： 键盘结构 键盘使用UIInputViewController实现 所有按键都是一个button，竖排的4个button放到一个竖向排列stackView中。 划分好的4个stackView放到一个横向排列的stackView中。 将横向stackView添加到inputView IdKeyBoard","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"http://yoursite.com/tags/自定义控件/"}]},{"title":"常用手机号、身份证号码、银行卡验证","slug":"verification","date":"2017-08-18T12:00:00.000Z","updated":"2017-10-20T05:09:10.000Z","comments":true,"path":"2017/08/18/verification/","link":"","permalink":"http://yoursite.com/2017/08/18/verification/","excerpt":"","text":"手机号1234567extension String &#123; var isPhoneNumber: Bool &#123; let pattern = \"^1+[3578]+\\\\d&#123;9&#125;\" let pred = NSPredicate(format: \"SELF MATCHES %@\", pattern) return pred.evaluate(with: self) &#125;&#125; 身份证号码有效性判断（18位二代身份证）身份证号码结构早期‘身份证号码’叫‘社会保障号’，为15位，1999年开始更名为公民身份证号码，即第二代身份证，为18位，且终身不变。 430512 19890813 136 7 公民身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 地址码： 表示编码对象常住户口所在县(市、旗、区)的行政区划代码。对于新生儿，该地址码为户口登记地行政区划代码。需要没说明的是，随着行政区划的调整，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。 出生日期码：表示编码对象出生的年、月、日，年、月、日代码之间不用分隔符，格式为YYYYMMDD，如19880328。按GB/T 7408的规定执行。 顺序码： 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。 校验码： 根据本体码，通过采用ISO 7064:1983,MOD 11-2校验码系统计算出校验码。算法可参考下文。前面有提到数字校验码，我们知道校验码也有X的，实质上为罗马字符X，相当于10. 校验码算法 十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, … , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 计算模 Y = mod(S, 11) 通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 实例分析 本体码为：11010519491231002 第一步： 各位数与对应加权因子乘积求和17+19+010+15+*=167 第二步：计算模167%11=2 第三步：根据余数2对照校验码得X 因此完整身份证号为：11010519491231002X swift代码1234567891011121314151617181920212223extension String &#123; var isIdCard: Bool &#123; guard self.characters.count == 18 else &#123; return false &#125; // 判断身份证号码格式 let pattern = \"^(^[1-9]\\\\d&#123;5&#125;[1-9]\\\\d&#123;3&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])((\\\\d&#123;4&#125;)|\\\\d&#123;3&#125;[Xx])$)$\" let pred = NSPredicate(format: \"SELF MATCHES %@\", pattern) guard pred.evaluate(with: self) else &#123; return false &#125; // 计算校验码 let strArr = Array(self.characters.dropLast(1)).flatMap &#123; Int(String($0)) &#125; let sum = strArr.enumerated().reduce(0) &#123; $0 + wi[$1.offset] * $1.element &#125; let lastStr = String(self.characters.last!) guard lastStr.lowercased() == checksumMap[sum % 11].lowercased() else &#123; return false &#125; return true &#125;&#125; 银行卡有效性判断银行卡结构 XXXXXX XXXXXXXXXXXX X 发卡行标识代码 自定义位 校验码 根据ISO标准，银行卡长度一般在13-19位，国际上也有12位的。银联标准卡卡长度一般是在16-19位，双组织卡也有13-19位的。校验码为银行卡号最后一位，采用LUHN算法，亦称模10算法。 luhn算法 反方向排列后，从右往左，奇数位乘以2； 清理两位数字：如果乘以2得到的数字是两位，即大于等于10，就把两位数字的个位十位相加得到一位数字； 相加模 10：清理后的所有数字相加，以10取模后，用10相减即得到效验数字 实例分析 卡号：5204 4080 8656 6492 反方向排列后，从右往左，奇数位乘以2； 先把最后一位数字2保留，作为校验码，然后把所有数字反向排列： 9 4 6 6 5 6 8 0 8 0 4 4 0 2 5 再把所有奇数为[9, 6, 5, 8, 8, 4, 0, 5]乘以2 18 4 12 6 10 6 16 0 16 0 8 4 0 2 10 清理两位数字：如果乘以2得到的数字是两位，即大于等于10，就把两位数字的个位十位相加得到一位数字； 两位的数字减去9得到的数字，即为该数字个位十位相加后的数字 9 4 3 6 1 6 7 0 7 0 8 4 0 2 1 所有的数字相加： 9+4+3+6+1+6+7+0+7+0+8+4+0+2+1 = 58 相加模 10 最后把计算出的数值加上校验码2 58+2=60 如果计算结果可以被10整除，则该卡号为有效的银行卡号 Swift代码123456789101112131415161718extension String &#123; var isBankCard: Bool &#123; let arr = Array(self.characters.reversed()).flatMap &#123; Int(String($0)) &#125; var sum = 0 for (i, element) in arr.enumerated() &#123; if i % 2 == 0 &#123; sum += element &#125; else &#123; var res = element * 2 if res &gt;= 10 &#123; res -= 9 &#125; sum += res &#125; &#125; return sum % 10 == 0 &#125;&#125;","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"常用代码","slug":"常用代码","permalink":"http://yoursite.com/tags/常用代码/"}]},{"title":"ZEDownloadManager 下载管理器","slug":"downloadManager","date":"2017-03-02T14:00:00.000Z","updated":"2017-10-20T05:19:55.000Z","comments":true,"path":"2017/03/02/downloadManager/","link":"","permalink":"http://yoursite.com/2017/03/02/downloadManager/","excerpt":"","text":"结构设计 ZEDownloadModel是下载任务的数据模型，下载任务的文件名、储存路径、下载进度、下载速度等。进度、状态的回调。 ZEDownloadOperation是NSOperation的子类，下载功能的实现、暂停等功能。 ZEDownloadManager单例，将上面俩个类集成，用户通过ZEDownloadManager对象的操作实现下载。 ZEDownloadModel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &lt;Foundation/Foundation.h&gt;@class ZEDownloadModel;typedef NS_ENUM(NSInteger, ZEDownloadState) &#123; ZEDownloadStateNone = 0, // 初始状态 ZEDownloadStateRunning = 1, // 下载中 ZEDownloadStateSuspended = 2, // 下载暂停 ZEDownloadStateCompleted = 3, // 下载完成 ZEDownloadStateFailed = 4, // 下载失败 ZEDownloadStateWaiting = 5 // 等待下载&#125;;typedef void(^ZEProgressChanged)(ZEDownloadModel *model);typedef void(^ZEStateChanged)(ZEDownloadModel *model);@interface ZEDownloadModel : NSObject/** 标题 */@property (nonatomic, copy) NSString *title;/** 下载链接 */@property (nonatomic, copy) NSString *downloadUrl;/** 下载速度 */@property (nonatomic, copy) NSString *speedString;/** 下载大小 */@property (nonatomic, copy) NSString *currentSize;/** 总大小 */@property (nonatomic, copy) NSString *totalSize;/** 文件地址 */@property (nonatomic, copy) NSString *localPath;/** 下载编号 用于排序 添加到下载管理器之前设置 */@property (nonatomic, assign) NSInteger downloadNum;/** 下载进度 0.0 ~ 1.0 */@property (nonatomic, assign) double progress;/** 下载状态 */@property (nonatomic, assign) ZEDownloadState state;/** 1s 前下载大小 */@property (nonatomic, assign) int64_t bytesWritten;/** 下载进度数据 */@property (nonatomic, strong) NSData *resumeData;/** 用于计算下载速度的时间 */@property (nonatomic, strong) NSDate *date;/** 下载按钮的title 可选设置 */@property (nonatomic, strong) NSString *stateString;@property (nonatomic, copy) ZEProgressChanged progressChanged;@property (nonatomic, copy) ZEStateChanged stateChanged;- (instancetype)initWtihTitle:(NSString*)title url:(NSString*)url;@end bytesWritten 和 date 是用于 间隔1秒计算一次下载大小和下载速度用的 downloadNum属性是任务的下载顺序，我设定的是始终优先下载最早加入的任务，效果如下 使用progressChanged和stateChanged Block实时刷新UI 其中是在progress和state的setter方法中调用 state的setter方法中设置提示信息和速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)setProgress:(double)progress &#123; _progress = progress; if (_progressChanged) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _progressChanged(self); &#125;); &#125;&#125;- (void)setState:(ZEDownloadState)state &#123; _state = state; switch (state) &#123; case ZEDownloadStateNone: &#123; self.stateString = @\"开始下载\"; break; &#125; case ZEDownloadStateRunning: &#123; self.stateString = @\"暂停\"; break; &#125; case ZEDownloadStateCompleted: &#123; self.stateString = @\"完成\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateWaiting: &#123; self.stateString = @\"等待\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateSuspended: &#123; self.stateString = @\"继续\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateFailed: &#123; self.stateString = @\"重新开始\"; self.speedString = @\"下载失败\"; break; &#125; &#125; if (_stateChanged) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _stateChanged(self); &#125;); &#125;&#125; ZEDownloadOperation12345678910111213141516171819202122232425262728typedef NS_OPTIONS(NSInteger,ZEOperationState) &#123; ZEOperationRuning = 0, ZEOperationCancelled = 1, ZEOperationComplete = 2,&#125;;/** 下载任务 继承NSOperation 使用NSOperationQueue管理 */@interface ZEDownloadOperation : NSOperation@property (nonatomic, strong) ZEDownloadModel *model;/** 任务状态 */@property (nonatomic, assign, readonly) ZEOperationState state;- (instancetype)initWith:(ZEDownloadModel *)model session:(NSURLSession *)session;/** 暂停下载 */- (void)suspend;/** 完成下载 */- (void)downloadFinished;@end ZEOperationState用于维护isExecuting、isFinished，NSOperationQueue根据这两个属性检测NSOperation的调度。 下载任务使用的NSURLSession为共享的session。 ZEDownloadOperation.m的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@interface ZEDownloadOperation()@property (nonatomic, strong) NSURLSessionDownloadTask *task;@property (nonatomic, strong) NSMutableURLRequest *request;@property (nonatomic, strong) NSURLSession *session;@end@implementation ZEDownloadOperation#pragma mark- life cycle- (instancetype)initWith:(ZEDownloadModel *)model session:(NSURLSession *)session &#123; if (self = [super init]) &#123; self.model = model; self.session = session; &#125; return self;&#125;- (void)dealloc &#123; self.task = nil; NSLog(@\"dealloc %@\",self.description);&#125;- (void)start &#123; // 创建下载任务 根据 resumeData 创建新任务或续传任务 if (!self.model.resumeData) &#123; self.task = [self.session downloadTaskWithRequest:self.request]; &#125; else &#123; self.task = [self.session downloadTaskWithResumeData:self.model.resumeData]; &#125; self.task.downloadModel = self.model; /** * 开始任务 */ [self.task resume]; [self updateState:ZEOperationRuning];&#125;#pragma mark- Public method- (void)suspend &#123; [self updateState:ZEOperationCancelled]; [self.task cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.model.resumeData = resumeData; &#125;];&#125;- (void)downloadFinished &#123; [self updateState:ZEOperationComplete];&#125;#pragma mark- Private method- (void)updateState:(ZEOperationState)state &#123; [self willChangeValueForKey:@\"isExecuting\"]; [self willChangeValueForKey:@\"isFinished\"]; _state = state; [self didChangeValueForKey:@\"isFinished\"]; [self didChangeValueForKey:@\"isExecuting\"]; &#125;#pragma mark- setter and getter- (NSMutableURLRequest *)request &#123; if (_request == nil) &#123; _request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:self.model.downloadUrl] cachePolicy: NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:20]; &#125; return _request;&#125;- (BOOL)isExecuting &#123; return self.state == ZEOperationRuning;&#125;- (BOOL)isFinished &#123; return self.state == ZEOperationComplete || self.state == ZEOperationCancelled;&#125;@end 重写start方法 开启下载任务，只要在start中判断model.resumeData是否为空，就可以新建下载任务或断点续传。 updateState:方法更新state的值，并手动通知isExecuting、isFinished的改变。 任务暂停就是取消下载任务，task调用cancelByProducingResumeData方法并存储resumeData值用以继续下载。 ZEDownloadManagerZEDownloadManager设计为单例,对外接口有存放所有任务的数组，添加任务、暂停任务、判断任务是否在以添加，可以设置最大下载数——默认为1. 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ZEDownloadManager : NSObject &#123; NSMutableArray *_downloadArr; NSMutableArray *_completeArr;&#125;/** 最大下载数 默认 1 */@property (nonatomic, assign) NSInteger maxDownloadCount;/** 所有下载任务 */@property (nonatomic, strong, readonly) NSArray *downloadArr;@property (nonatomic, strong, readonly) NSArray *completeArr;/** 获取单例对象 @return 实例对象 */+(instancetype)manager;/** 添加到下载管理器中 开始或等待下载 @param model 数据模型 */- (void)addDownLoad:(ZEDownloadModel *)model;/** 暂停 @param model 数据模型 */- (void)suspend:(ZEDownloadModel *)model;/** 开始 或 继续 @param model 数据模型 */- (void)resume:(ZEDownloadModel *)model;/** 是否在下载队列中 */- (BOOL)isExecuted:(ZEDownloadModel *)model; ####ZEDownloadManager.m 需要的属性 123456/** 共享的session */@property (nonatomic, strong) NSURLSession *session;/** 下载队列 */@property(strong,nonatomic) NSOperationQueue *downloadQueue;/** 等待队列 */@property (nonatomic, strong) NSMutableArray *waitingQueue; 正在下载的任务加入到downloadQueue，等待下载的任务加入到waitingQueue中，当downloadQueue中有任务完成时把waitingQueue中第一个任务取出加入到downloadQueue中，并在waitingQueue中删除 创建共享的NSURLSession 1234567891011121314151617- (NSURLSession *)session &#123; if (_session == nil) &#123; /** * 创建NSURLSessionConfiguration类的对象, 这个对象被用于创建NSURLSession类的对象. */ NSURLSessionConfiguration *configura = [NSURLSessionConfiguration defaultSessionConfiguration]; /** * 2. 创建NSURLSession的对象. * 参数一 : NSURLSessionConfiguration类的对象.(第1步创建的对象.) * 参数二 : session的代理人. 如果为nil, 系统将会提供一个代理人. * 参数三 : 一个队列, 代理方法在这个队列中执行. 如果为nil, 系统会自动创建一系列的队列. * 注: 只能通过这个方法给session设置代理人, 因为在NSURLSession中delegate属性是只读的. */ _session = [NSURLSession sessionWithConfiguration:configura delegate:self delegateQueue:nil]; &#125; return _session;&#125; 创建NSOperationQueue，管理正在下载的任务 123456- (NSOperationQueue *)downloadQueue &#123; if (_downloadQueue == nil) &#123; _downloadQueue = [[NSOperationQueue alloc]init]; &#125; return _downloadQueue;&#125; 添加任务 12345- (void)addDownLoad:(ZEDownloadModel *)model &#123; [_downloadArr addObject:model]; ZEDownloadOperation *operation = [[ZEDownloadOperation alloc]initWith:model session:self.session]; [self addDownArrOrWaitingArr:operation];&#125; addDownArrOrWaitingArr： 是将任务加入到下载队列或等待队列， 暂停任务 1234567891011- (void)suspend:(ZEDownloadModel *)model&#123; ZEDownloadOperation *operation = [self operatonForModel:model]; model.state = ZEDownloadStateSuspended; [operation suspend]; //下载队列未达到最大下载数 将operation添加到下载队列 并将自己从等待队列中删除 if (self.downloadQueue.operations.count &lt; self.maxDownloadCount) &#123; [self nextDownload]; &#125; else if ([self.waitingQueue containsObject:operation]) &#123; //下载队列达到最大下载数 将自己从等待队列中删除 [self.waitingQueue removeObject:operation]; &#125;&#125; 如果暂停下载中的任务就开始下一个，如果是暂停等待中的任务就在等待队列中删除。 继续下载 1234- (void)resume:(ZEDownloadModel *)model &#123; ZEDownloadOperation *operation = [self operatonForModel:model]; [self addDownArrOrWaitingArr:operation];&#125; 同样是调用addDownArrOrWaitingArr：方法，添加到等待队列后，对等待队列按model.downloadNum升序排序。 NSURLSessionDelegate 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma mark- NSURLSessionDelegate- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; NSDate *currentDate = [NSDate date]; NSTimeInterval interval = [currentDate timeIntervalSinceDate:downloadTask.downloadModel.date]; if (downloadTask.downloadModel.date == nil || interval &gt; 1 || totalBytesWritten == totalBytesExpectedToWrite) &#123; double progress = (double)totalBytesWritten / totalBytesExpectedToWrite; NSString *speedStr = [NSByteCountFormatter stringFromByteCount:totalBytesWritten - downloadTask.downloadModel.bytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; NSString *speedString = [speedStr stringByAppendingString:@\"/s\"]; NSString *currentSize = [NSByteCountFormatter stringFromByteCount:totalBytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; NSString *totalSize = [NSByteCountFormatter stringFromByteCount:totalBytesExpectedToWrite countStyle:NSByteCountFormatterCountStyleMemory]; downloadTask.downloadModel.bytesWritten = totalBytesWritten; downloadTask.downloadModel.speedString = speedString; downloadTask.downloadModel.progress = progress; downloadTask.downloadModel.currentSize = currentSize; downloadTask.downloadModel.totalSize = totalSize; downloadTask.downloadModel.date = currentDate; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; NSURL *filename = [documentsDirectoryURL URLByAppendingPathComponent:downloadTask.response.suggestedFilename]; [[NSFileManager defaultManager] moveItemAtURL:location toURL:filename error:nil]; NSLog(@\"fileUrl : %@\",filename.absoluteString); downloadTask.downloadModel.localPath = filename.absoluteString; downloadTask.downloadModel.state = ZEDownloadStateCompleted; ZEDownloadOperation *operation = [self findOperationInDownloadQueue:downloadTask.downloadModel]; [self moveToCompleteArr:operation]; [self nextDownload];&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error &#123; // code &lt; 0 是发生错误 -999 是task 被取消了 暂且如下处理 if (error.code &lt; 0 &amp;&amp; error.code != -999) &#123; NSLog(@\"发生错误\"); task.downloadModel.resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData]; task.downloadModel.state = ZEDownloadStateFailed; ZEDownloadOperation *operation = [self findOperationInDownloadQueue:task.downloadModel]; [operation downloadFinished]; &#125;&#125; 更新数据为1秒更新一次，*项目中对NSURLSessionTask添加了category，方便获取数据模型；error回调方法中，-999 是取消，以为在suspend方法中已经设置了model.state，并获取了resumeData数据，所以此处不做处理。 ZEDownloadManager使用1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; //设置最大下载数 ZEDownloader.maxDownloadCount = 2;&#125;- (void)download:(UIButton *)sender &#123; NSInteger index = sender.tag - 100; ZEDownloadModel *model = self.array[index]; [sender setBackgroundColor:[UIColor lightGrayColor]]; if ([ZEDownloader isExecuted:model]) &#123; NSLog(@\"该资源正在下载\"); return; &#125; model.downloadNum = ZEDownloader.downloadArr.count; [ZEDownloader addDownLoad:model];&#125; 获取进度等数据 12345678910111213- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; DownloadTableViewCell *displayCell = (DownloadTableViewCell *)cell; ZEDownloadModel *model = ZEDownloader.downloadArr[indexPath.row]; [displayCell setModel:model]; model.progressChanged = ^(ZEDownloadModel *model) &#123; [displayCell setModel:model]; &#125;; model.stateChanged = ^(ZEDownloadModel *model) &#123; [displayCell setModel:model]; [tableView reloadData]; &#125;;&#125; 功能都已近实现，具体可以查看Demo,如果有错误的地方欢迎指出。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"NSURLSession使用","slug":"NSURLSession","date":"2017-02-27T12:00:00.000Z","updated":"2017-10-20T05:16:13.000Z","comments":true,"path":"2017/02/27/NSURLSession/","link":"","permalink":"http://yoursite.com/2017/02/27/NSURLSession/","excerpt":"","text":"使用NSURLSession有两步： 通过NSURLSession的实例创建Task； 执行task NSURLSessionTaskNSURLSessionTask可以简单的理解为任务，如数据请求任务、上传任务、下载任务。 NSURLSessionTask 会话中任务的基类 NSURLSessionDataTask 数据请求任务 NSURLSessionUploadTask 上传任务 NSURLSessionDownloadTask 下载任务 NSURLSessionStreamTask 用于建立TCP/IP连接的任务 NSURLSessionDataTask数据请求任务常用的为Get和Post请求。 Get 12345678910NSURL *url = [NSURL URLWithString:@\"你的URL\"];// 获得共享的单例会话对象。NSURLSession *session = [NSURLSession sharedSession];// 创建任务NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 解析返回的数据 data &#125;];// 启动任务[task resume]; Post 1234567891011121314151617//确定请求路径NSURL *url = [NSURL URLWithString:@\"http://120.25.226.186:32812/login\"];//创建可变请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];//修改请求方法request.HTTPMethod = @\"POST\";//设置请求体request.HTTPBody = [@\"username=520&amp;pwd=520&amp;type=JSON\" dataUsingEncoding:NSUTF8StringEncoding];//创建会话对象NSURLSession *session = [NSURLSession sharedSession];//创建请求 TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 解析返回的数据 data &#125;];//发送请求[dataTask resume]; NSURLSessionDownloadTask 简单下载12345678910111213141516171819202122232425//确定请求路径 NSURL *url = [NSURL URLWithString:@\"http://120.25.226.186:32812/resources/images/minion_02.png\"]; //创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //创建会话对象 NSURLSession *session = [NSURLSession sharedSession]; //创建会话请求 //优点：该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题 NSURLSessionDownloadTask *downTask = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; //默认存储到临时文件夹 tmp 中，需要剪切文件到 cache NSLog(@\"%@\", location);//目标位置 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; /** fileURLWithPath:有协议头 URLWithString:无协议头 */ [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; &#125;]; //发送请求 [downTask resume]; 以上方法无法监听下载进度，如要获取下载进度，可以使用代理的方式进行下载。 NSURLSessionDownloadTask（断点续传） 创建NSURLSession，设置代理 123456789- (NSURLSession *)session &#123; if (_session == nil) &#123; NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; _session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil]; &#125; return _session;&#125; 开始下载 12345678// 开始下载- (IBAction)start:(id)sender &#123; if (!self.downloadTask) &#123; self.downloadTask = [self.session downloadTaskWithURL:URL]; [self.downloadTask resume]; self.titleLabel.text = @\"开始下载\"; &#125;&#125; 暂停下载 123456789// 暂停下载- (IBAction)pause:(id)sender &#123; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.resumeData = resumeData; self.downloadTask = nil; &#125;]; self.titleLabel.text = @\"暂停下载\"; self.speedLabel.text = @\"0KB/s\";&#125; 删除任务 (沙盒中的临时文件) 12345678910111213141516171819202122232425262728- (IBAction)delete:(id)sender &#123; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; // 将resumeData 序列化 NSError *listError = nil; NSDictionary *resumeDictionary = [NSPropertyListSerialization propertyListWithData:resumeData options:NSPropertyListImmutable format:nil error:&amp;listError]; if (listError) &#123; NSLog(@\"%@\",listError.description); &#125; // 取得临时文件的名字 NSString *fileName = [resumeDictionary objectForKey:@\"NSURLSessionResumeInfoTempFileName\"]; // 获取 tmp 临时文件夹 拼接临时文件名 NSString *tmp = [NSTemporaryDirectory() stringByAppendingString:fileName]; // 删除临时文件 NSError *fileError = nil; [[NSFileManager defaultManager] removeItemAtPath:tmp error:&amp;fileError]; if (fileError) &#123; NSLog(@\"%@\",fileEyrror.description); &#125; self.resumeData = nil; self.downloadTask = nil; &#125;]; self.titleLabel.text = @\"删除任务\"; self.progressView.progress = 0; self.progressLabel.text = @\"\"; self.speedLabel.text = @\"0KB/s\"; self.sizeLabel.text = @\"--/--\";&#125; 读取resumeData中临时文件的方法是在Stack Overflow找到的,实际上resumeData是一个plist文件 遵守NSURLSessionDelegate协议，实现协议方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//下载完成- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location &#123; //获取Downloads文件夹 NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDownloadsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:nil]; //修改文件名 NSURL *filename = [documentsDirectoryURL URLByAppendingPathComponent:downloadTask.response.suggestedFilename]; // 剪切文件 [[NSFileManager defaultManager] moveItemAtURL:location toURL:filename error:nil]; NSLog(@\"%@\",filename.path); self.downloadTask = nil; dispatch_async(dispatch_get_main_queue(), ^&#123; self.titleLabel.text = @\"下载完成\"; self.speedLabel.text = @\"0KB/s\"; self.pathLabel.text = filename.absoluteString; &#125;);&#125;//下载进度- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; //计算下载进度 double progress = (double)totalBytesWritten / totalBytesExpectedToWrite; //计算已经下载的大小 NSString *currentSize = [NSByteCountFormatter stringFromByteCount:totalBytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; //计算总大小 NSString *totalSize = [NSByteCountFormatter stringFromByteCount:totalBytesExpectedToWrite countStyle:NSByteCountFormatterCountStyleMemory]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.sizeLabel.text = [NSString stringWithFormat:@\"%@/%@\",currentSize,totalSize]; self.progressView.progress = progress; self.progressLabel.text = [NSString stringWithFormat:@\"%.1f%%\",progress*100]; &#125;); // 计算下载速度 NSDate *currentDate = [NSDate date]; NSTimeInterval interval = [currentDate timeIntervalSinceDate:self.date]; if (interval &gt;= 1 || totalBytesWritten == totalBytesExpectedToWrite) &#123; NSString *speedStr = [NSByteCountFormatter stringFromByteCount:(totalBytesWritten - self.totalBytesWritten)/interval countStyle:NSByteCountFormatterCountStyleMemory]; NSString *speedString = [speedStr stringByAppendingString:@\"/s\"]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.speedLabel.text = speedString; &#125;); self.totalBytesWritten = totalBytesWritten; self.date = currentDate; &#125;&#125; 断点续传的Demo","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"NSURLSessionConfiguration使用","slug":"NSURLSessionConfiguration","date":"2017-02-26T12:00:00.000Z","updated":"2017-10-20T05:15:11.000Z","comments":true,"path":"2017/02/26/NSURLSessionConfiguration/","link":"","permalink":"http://yoursite.com/2017/02/26/NSURLSessionConfiguration/","excerpt":"","text":"作用：可以统一配置NSURLSession，如请求超时、缓存策略等； 有三种创建方法1234567//返回标准配置，这实际上与NSURLConnection的网络协议栈是一样的，具有相同的共享NSHTTPCookieStorage，共享NSURLCache和共享NSURLCredentialStorage。+ (NSURLSessionConfiguration *)defaultSessionConfiguration;//返回一个预设配置，没有持久性存储的缓存，Cookie或证书。这对于实现像\"秘密浏览\"功能的功能来说，是很理想的。+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;//独特之处在于，它会创建一个后台会话。后台会话不同于常规的，普通的会话，它甚至可以在应用程序挂起，退出， 崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程提供上下文。+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0); 重要的属性 HTTPAdditionalHeaders 1234567891011121314151617# 替代 request 中的 forHTTPHeaderField 告诉服务器有关客户端的附加信息\"HTTPAdditionalHeaders\"指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。# WebDav的身份验证NSString *userPasswordString = [NSString stringWithFormat:@\"%@:%@\", user, password];NSData * userPasswordData = [userPasswordString dataUsingEncoding:NSUTF8StringEncoding];NSString *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:0];NSString *authString = [NSString stringWithFormat:@\"Basic: %@\", base64EncodedCredential];# 设置客户端类型NSString *userAgentString = @\"iPhone AppleWebKit\";configuration.HTTPAdditionalHeaders = @&#123;@\"Accept\": @\"application/json\", @\"Accept-Language\": @\"en\", @\"Authorization\": authString, @\"User-Agent\": userAgentString&#125;; networkServiceType（网络服务类型）：对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个 allowsCellularAccess（允许蜂窝访问）和discretionary（自行决定）：被用于节省通过蜂窝连接的带宽。建议在使用后台传输的时候，使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内 timeoutIntervalForRequest和timeoutIntervalForResource：指定了请求以及该资源的超时时间间隔。许多开发人员试图使用timeoutInterval去限制发送请求的总时间，但这误会了timeoutInterval的意思：报文之间的时间。timeoutIntervalForResource实际上提供了整体超时的特性，这应该只用于后台传输，而不是用户实际上可能想要等待的任何东西 HTTPMaximumConnectionsPerHost是 Foundation 框架中URL加载系统的一个新的配置选项。它曾经被用于NSURLConnection管理私人连接池。现在有了NSURLSession，开发者可以在需要时限制连接到特定主机的数量 HTTPShouldUsePipelining 也出现在NSMutableURLRequest，它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的 sessionSendsLaunchEvents 是另一个新的属性，该属性指定该会话是否应该从后台启动 connectionProxyDictionary 指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。关于连接代理的更多信息可以在 CFProxySupport Reference 找到。 Cookie Policies HTTPCookieStorage 是被会话使用的cookie存储。默认情况下，NSHTTPCookieShorage的 + sharedHTTPCookieStorage会被使用，这与NSURLConnection是相同的 HTTPCookieAcceptPolicy 决定了该会话应该接受从服务器发出的cookie的条件 HTTPShouldSetCookies 指定了请求是否应该使用会话HTTPCookieStorage的cookie Caching Policies URLCache 是会话使用的缓存。默认情况下，NSURLCache 的 + sharedURLCache 会被使用，这与NSURLConnection是相同的 requestCachePolicy 指定了一个请求的缓存响应应该在什么时候返回。这相当于NSURLRequest 的-cachePolicy方法 Custom Protocols","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"iOS CoreText计算每页显示的字数的方法","slug":"CoreText_PageStringCount","date":"2017-02-25T12:00:00.000Z","updated":"2017-10-20T05:20:39.000Z","comments":true,"path":"2017/02/25/CoreText_PageStringCount/","link":"","permalink":"http://yoursite.com/2017/02/25/CoreText_PageStringCount/","excerpt":"","text":"在做小说阅读器时，每章节的内容有很多文字，如果我们直接把章节的内容显示出来用户体验肯定不好，为此需要我们把章节内容分成几页去显示，每页的文字正好铺满我们设定的区域。下面的代码是用CoreText做的分页计算： 123456789101112131415161718192021222324252627 NSMutableAttributedString *str = [[NSMutableAttributedString alloc]initWithString:_contentText]; [str addAttributes:[self attributesWithFont:_contentFont] range:NSMakeRange(0, str.length)]; CFAttributedStringRef cfAttStr = (__bridge CFAttributedStringRef)str; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(cfAttStr); int textPos = 0; NSInteger totalPage = 0; NSUInteger strLength = [str length]; while (textPos &lt; strLength) &#123; //设置路径 CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, _textRenderSize.width, _textRenderSize.height), NULL); //生成frame CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, NULL);//获取范围并转换为NSRange CFRange frameRange = CTFrameGetVisibleStringRange(frame); NSRange range = NSMakeRange(frameRange.location, frameRange.length); //以NSString形式保存 [array addObject:NSStringFromRange(range)]; //移动当前文本位置 textPos += frameRange.length; CFRelease(frame); CGPathRelease(path); totalPage++; //释放路径和frame，页数加1 &#125; CFRelease(framesetter); 代码中只设置了文本的字号。 简易小说阅读器这是我没事的时候写的，当然还没写完，如果你有兴趣也可以加入进来。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"常用代码","slug":"常用代码","permalink":"http://yoursite.com/tags/常用代码/"}]},{"title":"Jenkins + xcode +Fir.im 自动构建项目 、打包ipa并上传","slug":"Jenkins_xcode _Fir.im","date":"2017-02-15T12:00:00.000Z","updated":"2017-10-20T05:25:34.000Z","comments":true,"path":"2017/02/15/Jenkins_xcode _Fir.im/","link":"","permalink":"http://yoursite.com/2017/02/15/Jenkins_xcode _Fir.im/","excerpt":"","text":"安装jenkins （命令行安装） 安装jenkins(需安装homebrew) 1brew install jenkins 启动jenkins 1jenkins 卸载jenkins 1brew uninstall jenkins 启动jenkins后使用浏览器访问jenkins http://localhost:8080/ 安装插件 首先确保安装了 OS X command line tools ,终端运行命令 1xcode-select - -install 使用Homebrew 及 RVM 安装Ruby，在安装 fir-cli 123456789Install Homebrew:ruby -e\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"install RVM:\\curl -sSL https://get.rvm.io|bash -s stable --rubygem install fir-cli 具体安装参考 官方工具 fir-cli 使用说明 创建一个新的项目 项目基本信息 源码管理源码管理中选择Git，配置仓库地址，认证账户，需要构建的分支等。 配置构建过程因为我的项目使用cocoapods进行依赖管理，故现增加一个Shell脚本的构建步骤。 配置Xcode integration新增Xcode integration 构建过程基础配置 target在本文的配置中可以不添 clean before build 勾选Yes Configuration 实在Xcode中的配置，默认有Debug和Release，这里的AdHoc是我自己在项目中添加的配置。 这里设置 .ipa 文件的名称。其中 ${JOB_NAME} 为本项目Job的名字，${BUILD_ID}为本次构建的版本号。 这里设置构建过程输出目录。其中 ${WORKSPACE} 为jenkins 提供的系统变量，为构建根目录。 代码签名及密匙配置 本文采用在Xcode 项目中 共享scheme 的方式，在 scheme 内部对代码签名和 Profile 做好了配置，同时 jenkins 所在的 Mac OSX 中有对应的证书和Profile，所以 1 中不需要做特殊配置，如果配置，将替换scheme中的配置。 在打包过程中，命令会由于系统的安全设置提醒输入密码，2中可以设置密匙所在路径及系统用户密码。 Keychain path ：${HOME}/Library/Keychains/login.keychain 为系统登录密匙路径。 Keychain password ： 填入电脑的用户密码。 【注】：Xcode中共享 scheme 的 方法 后边会说到。 Xcode高级构建配置 这里的Project就是我在Xcode项目中共享的scheme。 本文中的项目中包含有workspace，这里设置对应路径，不需要带上 .xcworkspace后缀。 Xcode项目所在目录。 Xcode项目文件路径，这里需要带上 .xcodeproj 后缀。 设置构建输出目录。 发布到fir.im新增一个 构建后操作步骤 这里添加 fir.im Token 从自己的fir.im账号里获取 启动构建 到这里自动构建就完成了 下面来说下共享Xcode项目中scheme “+” 可以新建scheme 将共享后的scheme 纳入版本管理后，就可以用按上边的步骤配置好的jenkins 来自动构建了。","categories":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/categories/Xcode/"}],"tags":[{"name":"CI","slug":"CI","permalink":"http://yoursite.com/tags/CI/"}]}]}