{"meta":{"title":"泽i blog","subtitle":null,"description":null,"author":"泽i","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-10-19T10:54:05.000Z","updated":"2017-10-19T10:54:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-19T10:52:27.000Z","updated":"2017-10-19T10:53:47.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Idkeyboard-自定义身份证号码键盘","slug":"Idkeyboard","date":"2017-10-20T07:19:30.000Z","updated":"2017-10-20T09:49:16.000Z","comments":true,"path":"2017/10/20/Idkeyboard/","link":"","permalink":"http://yoursite.com/2017/10/20/Idkeyboard/","excerpt":"","text":"项目中需要输入身份证号，系统自带的键盘用来输入很不方便，所以就需要自定做一个带X的数字键盘。 现在网上有很多都是通过循环创建button，在计算其frame。前几天看到了UIStackView，其可以使多个View按照横向或竖向对齐排列，就用stackView写了一个键盘。 效果如下： 键盘结构 键盘使用UIInputViewController实现 所有按键都是一个button，竖排的4个button放到一个竖向排列stackView中。 划分好的4个stackView放到一个横向排列的stackView中。 将横向stackView添加到inputView IdKeyBoard","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"自定义控件","slug":"自定义控件","permalink":"http://yoursite.com/tags/自定义控件/"}]},{"title":"常用手机号、身份证号码、银行卡验证","slug":"verification","date":"2017-08-18T12:00:00.000Z","updated":"2017-10-20T05:09:10.000Z","comments":true,"path":"2017/08/18/verification/","link":"","permalink":"http://yoursite.com/2017/08/18/verification/","excerpt":"","text":"手机号1234567extension String &#123; var isPhoneNumber: Bool &#123; let pattern = \"^1+[3578]+\\\\d&#123;9&#125;\" let pred = NSPredicate(format: \"SELF MATCHES %@\", pattern) return pred.evaluate(with: self) &#125;&#125; 身份证号码有效性判断（18位二代身份证）身份证号码结构早期‘身份证号码’叫‘社会保障号’，为15位，1999年开始更名为公民身份证号码，即第二代身份证，为18位，且终身不变。 430512 19890813 136 7 公民身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 地址码： 表示编码对象常住户口所在县(市、旗、区)的行政区划代码。对于新生儿，该地址码为户口登记地行政区划代码。需要没说明的是，随着行政区划的调整，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。 出生日期码：表示编码对象出生的年、月、日，年、月、日代码之间不用分隔符，格式为YYYYMMDD，如19880328。按GB/T 7408的规定执行。 顺序码： 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。 校验码： 根据本体码，通过采用ISO 7064:1983,MOD 11-2校验码系统计算出校验码。算法可参考下文。前面有提到数字校验码，我们知道校验码也有X的，实质上为罗马字符X，相当于10. 校验码算法 十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, … , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 计算模 Y = mod(S, 11) 通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 实例分析 本体码为：11010519491231002 第一步： 各位数与对应加权因子乘积求和17+19+010+15+*=167 第二步：计算模167%11=2 第三步：根据余数2对照校验码得X 因此完整身份证号为：11010519491231002X swift代码1234567891011121314151617181920212223extension String &#123; var isIdCard: Bool &#123; guard self.characters.count == 18 else &#123; return false &#125; // 判断身份证号码格式 let pattern = \"^(^[1-9]\\\\d&#123;5&#125;[1-9]\\\\d&#123;3&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])((\\\\d&#123;4&#125;)|\\\\d&#123;3&#125;[Xx])$)$\" let pred = NSPredicate(format: \"SELF MATCHES %@\", pattern) guard pred.evaluate(with: self) else &#123; return false &#125; // 计算校验码 let strArr = Array(self.characters.dropLast(1)).flatMap &#123; Int(String($0)) &#125; let sum = strArr.enumerated().reduce(0) &#123; $0 + wi[$1.offset] * $1.element &#125; let lastStr = String(self.characters.last!) guard lastStr.lowercased() == checksumMap[sum % 11].lowercased() else &#123; return false &#125; return true &#125;&#125; 银行卡有效性判断银行卡结构 XXXXXX XXXXXXXXXXXX X 发卡行标识代码 自定义位 校验码 根据ISO标准，银行卡长度一般在13-19位，国际上也有12位的。银联标准卡卡长度一般是在16-19位，双组织卡也有13-19位的。校验码为银行卡号最后一位，采用LUHN算法，亦称模10算法。 luhn算法 反方向排列后，从右往左，奇数位乘以2； 清理两位数字：如果乘以2得到的数字是两位，即大于等于10，就把两位数字的个位十位相加得到一位数字； 相加模 10：清理后的所有数字相加，以10取模后，用10相减即得到效验数字 实例分析 卡号：5204 4080 8656 6492 反方向排列后，从右往左，奇数位乘以2； 先把最后一位数字2保留，作为校验码，然后把所有数字反向排列： 9 4 6 6 5 6 8 0 8 0 4 4 0 2 5 再把所有奇数为[9, 6, 5, 8, 8, 4, 0, 5]乘以2 18 4 12 6 10 6 16 0 16 0 8 4 0 2 10 清理两位数字：如果乘以2得到的数字是两位，即大于等于10，就把两位数字的个位十位相加得到一位数字； 两位的数字减去9得到的数字，即为该数字个位十位相加后的数字 9 4 3 6 1 6 7 0 7 0 8 4 0 2 1 所有的数字相加： 9+4+3+6+1+6+7+0+7+0+8+4+0+2+1 = 58 相加模 10 最后把计算出的数值加上校验码2 58+2=60 如果计算结果可以被10整除，则该卡号为有效的银行卡号 Swift代码123456789101112131415161718extension String &#123; var isBankCard: Bool &#123; let arr = Array(self.characters.reversed()).flatMap &#123; Int(String($0)) &#125; var sum = 0 for (i, element) in arr.enumerated() &#123; if i % 2 == 0 &#123; sum += element &#125; else &#123; var res = element * 2 if res &gt;= 10 &#123; res -= 9 &#125; sum += res &#125; &#125; return sum % 10 == 0 &#125;&#125;","categories":[{"name":"swift","slug":"swift","permalink":"http://yoursite.com/categories/swift/"}],"tags":[{"name":"常用代码","slug":"常用代码","permalink":"http://yoursite.com/tags/常用代码/"}]},{"title":"ZEDownloadManager 下载管理器","slug":"downloadManager","date":"2017-03-02T14:00:00.000Z","updated":"2017-10-20T05:19:55.000Z","comments":true,"path":"2017/03/02/downloadManager/","link":"","permalink":"http://yoursite.com/2017/03/02/downloadManager/","excerpt":"","text":"结构设计 ZEDownloadModel是下载任务的数据模型，下载任务的文件名、储存路径、下载进度、下载速度等。进度、状态的回调。 ZEDownloadOperation是NSOperation的子类，下载功能的实现、暂停等功能。 ZEDownloadManager单例，将上面俩个类集成，用户通过ZEDownloadManager对象的操作实现下载。 ZEDownloadModel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &lt;Foundation/Foundation.h&gt;@class ZEDownloadModel;typedef NS_ENUM(NSInteger, ZEDownloadState) &#123; ZEDownloadStateNone = 0, // 初始状态 ZEDownloadStateRunning = 1, // 下载中 ZEDownloadStateSuspended = 2, // 下载暂停 ZEDownloadStateCompleted = 3, // 下载完成 ZEDownloadStateFailed = 4, // 下载失败 ZEDownloadStateWaiting = 5 // 等待下载&#125;;typedef void(^ZEProgressChanged)(ZEDownloadModel *model);typedef void(^ZEStateChanged)(ZEDownloadModel *model);@interface ZEDownloadModel : NSObject/** 标题 */@property (nonatomic, copy) NSString *title;/** 下载链接 */@property (nonatomic, copy) NSString *downloadUrl;/** 下载速度 */@property (nonatomic, copy) NSString *speedString;/** 下载大小 */@property (nonatomic, copy) NSString *currentSize;/** 总大小 */@property (nonatomic, copy) NSString *totalSize;/** 文件地址 */@property (nonatomic, copy) NSString *localPath;/** 下载编号 用于排序 添加到下载管理器之前设置 */@property (nonatomic, assign) NSInteger downloadNum;/** 下载进度 0.0 ~ 1.0 */@property (nonatomic, assign) double progress;/** 下载状态 */@property (nonatomic, assign) ZEDownloadState state;/** 1s 前下载大小 */@property (nonatomic, assign) int64_t bytesWritten;/** 下载进度数据 */@property (nonatomic, strong) NSData *resumeData;/** 用于计算下载速度的时间 */@property (nonatomic, strong) NSDate *date;/** 下载按钮的title 可选设置 */@property (nonatomic, strong) NSString *stateString;@property (nonatomic, copy) ZEProgressChanged progressChanged;@property (nonatomic, copy) ZEStateChanged stateChanged;- (instancetype)initWtihTitle:(NSString*)title url:(NSString*)url;@end bytesWritten 和 date 是用于 间隔1秒计算一次下载大小和下载速度用的 downloadNum属性是任务的下载顺序，我设定的是始终优先下载最早加入的任务，效果如下 使用progressChanged和stateChanged Block实时刷新UI 其中是在progress和state的setter方法中调用 state的setter方法中设置提示信息和速度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)setProgress:(double)progress &#123; _progress = progress; if (_progressChanged) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _progressChanged(self); &#125;); &#125;&#125;- (void)setState:(ZEDownloadState)state &#123; _state = state; switch (state) &#123; case ZEDownloadStateNone: &#123; self.stateString = @\"开始下载\"; break; &#125; case ZEDownloadStateRunning: &#123; self.stateString = @\"暂停\"; break; &#125; case ZEDownloadStateCompleted: &#123; self.stateString = @\"完成\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateWaiting: &#123; self.stateString = @\"等待\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateSuspended: &#123; self.stateString = @\"继续\"; self.speedString = @\"\"; break; &#125; case ZEDownloadStateFailed: &#123; self.stateString = @\"重新开始\"; self.speedString = @\"下载失败\"; break; &#125; &#125; if (_stateChanged) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _stateChanged(self); &#125;); &#125;&#125; ZEDownloadOperation12345678910111213141516171819202122232425262728typedef NS_OPTIONS(NSInteger,ZEOperationState) &#123; ZEOperationRuning = 0, ZEOperationCancelled = 1, ZEOperationComplete = 2,&#125;;/** 下载任务 继承NSOperation 使用NSOperationQueue管理 */@interface ZEDownloadOperation : NSOperation@property (nonatomic, strong) ZEDownloadModel *model;/** 任务状态 */@property (nonatomic, assign, readonly) ZEOperationState state;- (instancetype)initWith:(ZEDownloadModel *)model session:(NSURLSession *)session;/** 暂停下载 */- (void)suspend;/** 完成下载 */- (void)downloadFinished;@end ZEOperationState用于维护isExecuting、isFinished，NSOperationQueue根据这两个属性检测NSOperation的调度。 下载任务使用的NSURLSession为共享的session。 ZEDownloadOperation.m的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@interface ZEDownloadOperation()@property (nonatomic, strong) NSURLSessionDownloadTask *task;@property (nonatomic, strong) NSMutableURLRequest *request;@property (nonatomic, strong) NSURLSession *session;@end@implementation ZEDownloadOperation#pragma mark- life cycle- (instancetype)initWith:(ZEDownloadModel *)model session:(NSURLSession *)session &#123; if (self = [super init]) &#123; self.model = model; self.session = session; &#125; return self;&#125;- (void)dealloc &#123; self.task = nil; NSLog(@\"dealloc %@\",self.description);&#125;- (void)start &#123; // 创建下载任务 根据 resumeData 创建新任务或续传任务 if (!self.model.resumeData) &#123; self.task = [self.session downloadTaskWithRequest:self.request]; &#125; else &#123; self.task = [self.session downloadTaskWithResumeData:self.model.resumeData]; &#125; self.task.downloadModel = self.model; /** * 开始任务 */ [self.task resume]; [self updateState:ZEOperationRuning];&#125;#pragma mark- Public method- (void)suspend &#123; [self updateState:ZEOperationCancelled]; [self.task cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.model.resumeData = resumeData; &#125;];&#125;- (void)downloadFinished &#123; [self updateState:ZEOperationComplete];&#125;#pragma mark- Private method- (void)updateState:(ZEOperationState)state &#123; [self willChangeValueForKey:@\"isExecuting\"]; [self willChangeValueForKey:@\"isFinished\"]; _state = state; [self didChangeValueForKey:@\"isFinished\"]; [self didChangeValueForKey:@\"isExecuting\"]; &#125;#pragma mark- setter and getter- (NSMutableURLRequest *)request &#123; if (_request == nil) &#123; _request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:self.model.downloadUrl] cachePolicy: NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:20]; &#125; return _request;&#125;- (BOOL)isExecuting &#123; return self.state == ZEOperationRuning;&#125;- (BOOL)isFinished &#123; return self.state == ZEOperationComplete || self.state == ZEOperationCancelled;&#125;@end 重写start方法 开启下载任务，只要在start中判断model.resumeData是否为空，就可以新建下载任务或断点续传。 updateState:方法更新state的值，并手动通知isExecuting、isFinished的改变。 任务暂停就是取消下载任务，task调用cancelByProducingResumeData方法并存储resumeData值用以继续下载。 ZEDownloadManagerZEDownloadManager设计为单例,对外接口有存放所有任务的数组，添加任务、暂停任务、判断任务是否在以添加，可以设置最大下载数——默认为1. 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ZEDownloadManager : NSObject &#123; NSMutableArray *_downloadArr; NSMutableArray *_completeArr;&#125;/** 最大下载数 默认 1 */@property (nonatomic, assign) NSInteger maxDownloadCount;/** 所有下载任务 */@property (nonatomic, strong, readonly) NSArray *downloadArr;@property (nonatomic, strong, readonly) NSArray *completeArr;/** 获取单例对象 @return 实例对象 */+(instancetype)manager;/** 添加到下载管理器中 开始或等待下载 @param model 数据模型 */- (void)addDownLoad:(ZEDownloadModel *)model;/** 暂停 @param model 数据模型 */- (void)suspend:(ZEDownloadModel *)model;/** 开始 或 继续 @param model 数据模型 */- (void)resume:(ZEDownloadModel *)model;/** 是否在下载队列中 */- (BOOL)isExecuted:(ZEDownloadModel *)model; ####ZEDownloadManager.m 需要的属性 123456/** 共享的session */@property (nonatomic, strong) NSURLSession *session;/** 下载队列 */@property(strong,nonatomic) NSOperationQueue *downloadQueue;/** 等待队列 */@property (nonatomic, strong) NSMutableArray *waitingQueue; 正在下载的任务加入到downloadQueue，等待下载的任务加入到waitingQueue中，当downloadQueue中有任务完成时把waitingQueue中第一个任务取出加入到downloadQueue中，并在waitingQueue中删除 创建共享的NSURLSession 1234567891011121314151617- (NSURLSession *)session &#123; if (_session == nil) &#123; /** * 创建NSURLSessionConfiguration类的对象, 这个对象被用于创建NSURLSession类的对象. */ NSURLSessionConfiguration *configura = [NSURLSessionConfiguration defaultSessionConfiguration]; /** * 2. 创建NSURLSession的对象. * 参数一 : NSURLSessionConfiguration类的对象.(第1步创建的对象.) * 参数二 : session的代理人. 如果为nil, 系统将会提供一个代理人. * 参数三 : 一个队列, 代理方法在这个队列中执行. 如果为nil, 系统会自动创建一系列的队列. * 注: 只能通过这个方法给session设置代理人, 因为在NSURLSession中delegate属性是只读的. */ _session = [NSURLSession sessionWithConfiguration:configura delegate:self delegateQueue:nil]; &#125; return _session;&#125; 创建NSOperationQueue，管理正在下载的任务 123456- (NSOperationQueue *)downloadQueue &#123; if (_downloadQueue == nil) &#123; _downloadQueue = [[NSOperationQueue alloc]init]; &#125; return _downloadQueue;&#125; 添加任务 12345- (void)addDownLoad:(ZEDownloadModel *)model &#123; [_downloadArr addObject:model]; ZEDownloadOperation *operation = [[ZEDownloadOperation alloc]initWith:model session:self.session]; [self addDownArrOrWaitingArr:operation];&#125; addDownArrOrWaitingArr： 是将任务加入到下载队列或等待队列， 暂停任务 1234567891011- (void)suspend:(ZEDownloadModel *)model&#123; ZEDownloadOperation *operation = [self operatonForModel:model]; model.state = ZEDownloadStateSuspended; [operation suspend]; //下载队列未达到最大下载数 将operation添加到下载队列 并将自己从等待队列中删除 if (self.downloadQueue.operations.count &lt; self.maxDownloadCount) &#123; [self nextDownload]; &#125; else if ([self.waitingQueue containsObject:operation]) &#123; //下载队列达到最大下载数 将自己从等待队列中删除 [self.waitingQueue removeObject:operation]; &#125;&#125; 如果暂停下载中的任务就开始下一个，如果是暂停等待中的任务就在等待队列中删除。 继续下载 1234- (void)resume:(ZEDownloadModel *)model &#123; ZEDownloadOperation *operation = [self operatonForModel:model]; [self addDownArrOrWaitingArr:operation];&#125; 同样是调用addDownArrOrWaitingArr：方法，添加到等待队列后，对等待队列按model.downloadNum升序排序。 NSURLSessionDelegate 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma mark- NSURLSessionDelegate- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; NSDate *currentDate = [NSDate date]; NSTimeInterval interval = [currentDate timeIntervalSinceDate:downloadTask.downloadModel.date]; if (downloadTask.downloadModel.date == nil || interval &gt; 1 || totalBytesWritten == totalBytesExpectedToWrite) &#123; double progress = (double)totalBytesWritten / totalBytesExpectedToWrite; NSString *speedStr = [NSByteCountFormatter stringFromByteCount:totalBytesWritten - downloadTask.downloadModel.bytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; NSString *speedString = [speedStr stringByAppendingString:@\"/s\"]; NSString *currentSize = [NSByteCountFormatter stringFromByteCount:totalBytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; NSString *totalSize = [NSByteCountFormatter stringFromByteCount:totalBytesExpectedToWrite countStyle:NSByteCountFormatterCountStyleMemory]; downloadTask.downloadModel.bytesWritten = totalBytesWritten; downloadTask.downloadModel.speedString = speedString; downloadTask.downloadModel.progress = progress; downloadTask.downloadModel.currentSize = currentSize; downloadTask.downloadModel.totalSize = totalSize; downloadTask.downloadModel.date = currentDate; &#125;&#125;- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123; NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; NSURL *filename = [documentsDirectoryURL URLByAppendingPathComponent:downloadTask.response.suggestedFilename]; [[NSFileManager defaultManager] moveItemAtURL:location toURL:filename error:nil]; NSLog(@\"fileUrl : %@\",filename.absoluteString); downloadTask.downloadModel.localPath = filename.absoluteString; downloadTask.downloadModel.state = ZEDownloadStateCompleted; ZEDownloadOperation *operation = [self findOperationInDownloadQueue:downloadTask.downloadModel]; [self moveToCompleteArr:operation]; [self nextDownload];&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error &#123; // code &lt; 0 是发生错误 -999 是task 被取消了 暂且如下处理 if (error.code &lt; 0 &amp;&amp; error.code != -999) &#123; NSLog(@\"发生错误\"); task.downloadModel.resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData]; task.downloadModel.state = ZEDownloadStateFailed; ZEDownloadOperation *operation = [self findOperationInDownloadQueue:task.downloadModel]; [operation downloadFinished]; &#125;&#125; 更新数据为1秒更新一次，*项目中对NSURLSessionTask添加了category，方便获取数据模型；error回调方法中，-999 是取消，以为在suspend方法中已经设置了model.state，并获取了resumeData数据，所以此处不做处理。 ZEDownloadManager使用1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; //设置最大下载数 ZEDownloader.maxDownloadCount = 2;&#125;- (void)download:(UIButton *)sender &#123; NSInteger index = sender.tag - 100; ZEDownloadModel *model = self.array[index]; [sender setBackgroundColor:[UIColor lightGrayColor]]; if ([ZEDownloader isExecuted:model]) &#123; NSLog(@\"该资源正在下载\"); return; &#125; model.downloadNum = ZEDownloader.downloadArr.count; [ZEDownloader addDownLoad:model];&#125; 获取进度等数据 12345678910111213- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; DownloadTableViewCell *displayCell = (DownloadTableViewCell *)cell; ZEDownloadModel *model = ZEDownloader.downloadArr[indexPath.row]; [displayCell setModel:model]; model.progressChanged = ^(ZEDownloadModel *model) &#123; [displayCell setModel:model]; &#125;; model.stateChanged = ^(ZEDownloadModel *model) &#123; [displayCell setModel:model]; [tableView reloadData]; &#125;;&#125; 功能都已近实现，具体可以查看Demo,如果有错误的地方欢迎指出。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"NSURLSession使用","slug":"NSURLSession","date":"2017-02-27T12:00:00.000Z","updated":"2017-10-20T05:16:13.000Z","comments":true,"path":"2017/02/27/NSURLSession/","link":"","permalink":"http://yoursite.com/2017/02/27/NSURLSession/","excerpt":"","text":"使用NSURLSession有两步： 通过NSURLSession的实例创建Task； 执行task NSURLSessionTaskNSURLSessionTask可以简单的理解为任务，如数据请求任务、上传任务、下载任务。 NSURLSessionTask 会话中任务的基类 NSURLSessionDataTask 数据请求任务 NSURLSessionUploadTask 上传任务 NSURLSessionDownloadTask 下载任务 NSURLSessionStreamTask 用于建立TCP/IP连接的任务 NSURLSessionDataTask数据请求任务常用的为Get和Post请求。 Get 12345678910NSURL *url = [NSURL URLWithString:@\"你的URL\"];// 获得共享的单例会话对象。NSURLSession *session = [NSURLSession sharedSession];// 创建任务NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 解析返回的数据 data &#125;];// 启动任务[task resume]; Post 1234567891011121314151617//确定请求路径NSURL *url = [NSURL URLWithString:@\"http://120.25.226.186:32812/login\"];//创建可变请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];//修改请求方法request.HTTPMethod = @\"POST\";//设置请求体request.HTTPBody = [@\"username=520&amp;pwd=520&amp;type=JSON\" dataUsingEncoding:NSUTF8StringEncoding];//创建会话对象NSURLSession *session = [NSURLSession sharedSession];//创建请求 TaskNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; // 解析返回的数据 data &#125;];//发送请求[dataTask resume]; NSURLSessionDownloadTask 简单下载12345678910111213141516171819202122232425//确定请求路径 NSURL *url = [NSURL URLWithString:@\"http://120.25.226.186:32812/resources/images/minion_02.png\"]; //创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //创建会话对象 NSURLSession *session = [NSURLSession sharedSession]; //创建会话请求 //优点：该方法内部已经完成了边接收数据边写沙盒的操作，解决了内存飙升的问题 NSURLSessionDownloadTask *downTask = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; //默认存储到临时文件夹 tmp 中，需要剪切文件到 cache NSLog(@\"%@\", location);//目标位置 NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; /** fileURLWithPath:有协议头 URLWithString:无协议头 */ [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:fullPath] error:nil]; &#125;]; //发送请求 [downTask resume]; 以上方法无法监听下载进度，如要获取下载进度，可以使用代理的方式进行下载。 NSURLSessionDownloadTask（断点续传） 创建NSURLSession，设置代理 123456789- (NSURLSession *)session &#123; if (_session == nil) &#123; NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; _session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil]; &#125; return _session;&#125; 开始下载 12345678// 开始下载- (IBAction)start:(id)sender &#123; if (!self.downloadTask) &#123; self.downloadTask = [self.session downloadTaskWithURL:URL]; [self.downloadTask resume]; self.titleLabel.text = @\"开始下载\"; &#125;&#125; 暂停下载 123456789// 暂停下载- (IBAction)pause:(id)sender &#123; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; self.resumeData = resumeData; self.downloadTask = nil; &#125;]; self.titleLabel.text = @\"暂停下载\"; self.speedLabel.text = @\"0KB/s\";&#125; 删除任务 (沙盒中的临时文件) 12345678910111213141516171819202122232425262728- (IBAction)delete:(id)sender &#123; [self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123; // 将resumeData 序列化 NSError *listError = nil; NSDictionary *resumeDictionary = [NSPropertyListSerialization propertyListWithData:resumeData options:NSPropertyListImmutable format:nil error:&amp;listError]; if (listError) &#123; NSLog(@\"%@\",listError.description); &#125; // 取得临时文件的名字 NSString *fileName = [resumeDictionary objectForKey:@\"NSURLSessionResumeInfoTempFileName\"]; // 获取 tmp 临时文件夹 拼接临时文件名 NSString *tmp = [NSTemporaryDirectory() stringByAppendingString:fileName]; // 删除临时文件 NSError *fileError = nil; [[NSFileManager defaultManager] removeItemAtPath:tmp error:&amp;fileError]; if (fileError) &#123; NSLog(@\"%@\",fileEyrror.description); &#125; self.resumeData = nil; self.downloadTask = nil; &#125;]; self.titleLabel.text = @\"删除任务\"; self.progressView.progress = 0; self.progressLabel.text = @\"\"; self.speedLabel.text = @\"0KB/s\"; self.sizeLabel.text = @\"--/--\";&#125; 读取resumeData中临时文件的方法是在Stack Overflow找到的,实际上resumeData是一个plist文件 遵守NSURLSessionDelegate协议，实现协议方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//下载完成- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location &#123; //获取Downloads文件夹 NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDownloadsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:nil]; //修改文件名 NSURL *filename = [documentsDirectoryURL URLByAppendingPathComponent:downloadTask.response.suggestedFilename]; // 剪切文件 [[NSFileManager defaultManager] moveItemAtURL:location toURL:filename error:nil]; NSLog(@\"%@\",filename.path); self.downloadTask = nil; dispatch_async(dispatch_get_main_queue(), ^&#123; self.titleLabel.text = @\"下载完成\"; self.speedLabel.text = @\"0KB/s\"; self.pathLabel.text = filename.absoluteString; &#125;);&#125;//下载进度- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123; //计算下载进度 double progress = (double)totalBytesWritten / totalBytesExpectedToWrite; //计算已经下载的大小 NSString *currentSize = [NSByteCountFormatter stringFromByteCount:totalBytesWritten countStyle:NSByteCountFormatterCountStyleMemory]; //计算总大小 NSString *totalSize = [NSByteCountFormatter stringFromByteCount:totalBytesExpectedToWrite countStyle:NSByteCountFormatterCountStyleMemory]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.sizeLabel.text = [NSString stringWithFormat:@\"%@/%@\",currentSize,totalSize]; self.progressView.progress = progress; self.progressLabel.text = [NSString stringWithFormat:@\"%.1f%%\",progress*100]; &#125;); // 计算下载速度 NSDate *currentDate = [NSDate date]; NSTimeInterval interval = [currentDate timeIntervalSinceDate:self.date]; if (interval &gt;= 1 || totalBytesWritten == totalBytesExpectedToWrite) &#123; NSString *speedStr = [NSByteCountFormatter stringFromByteCount:(totalBytesWritten - self.totalBytesWritten)/interval countStyle:NSByteCountFormatterCountStyleMemory]; NSString *speedString = [speedStr stringByAppendingString:@\"/s\"]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.speedLabel.text = speedString; &#125;); self.totalBytesWritten = totalBytesWritten; self.date = currentDate; &#125;&#125; 断点续传的Demo","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"NSURLSessionConfiguration使用","slug":"NSURLSessionConfiguration","date":"2017-02-26T12:00:00.000Z","updated":"2017-10-20T05:15:11.000Z","comments":true,"path":"2017/02/26/NSURLSessionConfiguration/","link":"","permalink":"http://yoursite.com/2017/02/26/NSURLSessionConfiguration/","excerpt":"","text":"作用：可以统一配置NSURLSession，如请求超时、缓存策略等； 有三种创建方法1234567//返回标准配置，这实际上与NSURLConnection的网络协议栈是一样的，具有相同的共享NSHTTPCookieStorage，共享NSURLCache和共享NSURLCredentialStorage。+ (NSURLSessionConfiguration *)defaultSessionConfiguration;//返回一个预设配置，没有持久性存储的缓存，Cookie或证书。这对于实现像\"秘密浏览\"功能的功能来说，是很理想的。+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;//独特之处在于，它会创建一个后台会话。后台会话不同于常规的，普通的会话，它甚至可以在应用程序挂起，退出， 崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程提供上下文。+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0); 重要的属性 HTTPAdditionalHeaders 1234567891011121314151617# 替代 request 中的 forHTTPHeaderField 告诉服务器有关客户端的附加信息\"HTTPAdditionalHeaders\"指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。# WebDav的身份验证NSString *userPasswordString = [NSString stringWithFormat:@\"%@:%@\", user, password];NSData * userPasswordData = [userPasswordString dataUsingEncoding:NSUTF8StringEncoding];NSString *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:0];NSString *authString = [NSString stringWithFormat:@\"Basic: %@\", base64EncodedCredential];# 设置客户端类型NSString *userAgentString = @\"iPhone AppleWebKit\";configuration.HTTPAdditionalHeaders = @&#123;@\"Accept\": @\"application/json\", @\"Accept-Language\": @\"en\", @\"Authorization\": authString, @\"User-Agent\": userAgentString&#125;; networkServiceType（网络服务类型）：对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个 allowsCellularAccess（允许蜂窝访问）和discretionary（自行决定）：被用于节省通过蜂窝连接的带宽。建议在使用后台传输的时候，使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内 timeoutIntervalForRequest和timeoutIntervalForResource：指定了请求以及该资源的超时时间间隔。许多开发人员试图使用timeoutInterval去限制发送请求的总时间，但这误会了timeoutInterval的意思：报文之间的时间。timeoutIntervalForResource实际上提供了整体超时的特性，这应该只用于后台传输，而不是用户实际上可能想要等待的任何东西 HTTPMaximumConnectionsPerHost是 Foundation 框架中URL加载系统的一个新的配置选项。它曾经被用于NSURLConnection管理私人连接池。现在有了NSURLSession，开发者可以在需要时限制连接到特定主机的数量 HTTPShouldUsePipelining 也出现在NSMutableURLRequest，它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的 sessionSendsLaunchEvents 是另一个新的属性，该属性指定该会话是否应该从后台启动 connectionProxyDictionary 指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。关于连接代理的更多信息可以在 CFProxySupport Reference 找到。 Cookie Policies HTTPCookieStorage 是被会话使用的cookie存储。默认情况下，NSHTTPCookieShorage的 + sharedHTTPCookieStorage会被使用，这与NSURLConnection是相同的 HTTPCookieAcceptPolicy 决定了该会话应该接受从服务器发出的cookie的条件 HTTPShouldSetCookies 指定了请求是否应该使用会话HTTPCookieStorage的cookie Caching Policies URLCache 是会话使用的缓存。默认情况下，NSURLCache 的 + sharedURLCache 会被使用，这与NSURLConnection是相同的 requestCachePolicy 指定了一个请求的缓存响应应该在什么时候返回。这相当于NSURLRequest 的-cachePolicy方法 Custom Protocols","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"iOS CoreText计算每页显示的字数的方法","slug":"CoreText_PageStringCount","date":"2017-02-25T12:00:00.000Z","updated":"2017-10-20T05:20:39.000Z","comments":true,"path":"2017/02/25/CoreText_PageStringCount/","link":"","permalink":"http://yoursite.com/2017/02/25/CoreText_PageStringCount/","excerpt":"","text":"在做小说阅读器时，每章节的内容有很多文字，如果我们直接把章节的内容显示出来用户体验肯定不好，为此需要我们把章节内容分成几页去显示，每页的文字正好铺满我们设定的区域。下面的代码是用CoreText做的分页计算： 123456789101112131415161718192021222324252627 NSMutableAttributedString *str = [[NSMutableAttributedString alloc]initWithString:_contentText]; [str addAttributes:[self attributesWithFont:_contentFont] range:NSMakeRange(0, str.length)]; CFAttributedStringRef cfAttStr = (__bridge CFAttributedStringRef)str; CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(cfAttStr); int textPos = 0; NSInteger totalPage = 0; NSUInteger strLength = [str length]; while (textPos &lt; strLength) &#123; //设置路径 CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, _textRenderSize.width, _textRenderSize.height), NULL); //生成frame CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(textPos, 0), path, NULL);//获取范围并转换为NSRange CFRange frameRange = CTFrameGetVisibleStringRange(frame); NSRange range = NSMakeRange(frameRange.location, frameRange.length); //以NSString形式保存 [array addObject:NSStringFromRange(range)]; //移动当前文本位置 textPos += frameRange.length; CFRelease(frame); CGPathRelease(path); totalPage++; //释放路径和frame，页数加1 &#125; CFRelease(framesetter); 代码中只设置了文本的字号。 简易小说阅读器这是我没事的时候写的，当然还没写完，如果你有兴趣也可以加入进来。","categories":[{"name":"OC","slug":"OC","permalink":"http://yoursite.com/categories/OC/"}],"tags":[{"name":"常用代码","slug":"常用代码","permalink":"http://yoursite.com/tags/常用代码/"}]},{"title":"Jenkins + xcode +Fir.im 自动构建项目 、打包ipa并上传","slug":"Jenkins_xcode _Fir.im","date":"2017-02-15T12:00:00.000Z","updated":"2017-10-20T05:25:34.000Z","comments":true,"path":"2017/02/15/Jenkins_xcode _Fir.im/","link":"","permalink":"http://yoursite.com/2017/02/15/Jenkins_xcode _Fir.im/","excerpt":"","text":"安装jenkins （命令行安装） 安装jenkins(需安装homebrew) 1brew install jenkins 启动jenkins 1jenkins 卸载jenkins 1brew uninstall jenkins 启动jenkins后使用浏览器访问jenkins http://localhost:8080/ 安装插件 首先确保安装了 OS X command line tools ,终端运行命令 1xcode-select - -install 使用Homebrew 及 RVM 安装Ruby，在安装 fir-cli 123456789Install Homebrew:ruby -e\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"install RVM:\\curl -sSL https://get.rvm.io|bash -s stable --rubygem install fir-cli 具体安装参考 官方工具 fir-cli 使用说明 创建一个新的项目 项目基本信息 源码管理源码管理中选择Git，配置仓库地址，认证账户，需要构建的分支等。 配置构建过程因为我的项目使用cocoapods进行依赖管理，故现增加一个Shell脚本的构建步骤。 配置Xcode integration新增Xcode integration 构建过程基础配置 target在本文的配置中可以不添 clean before build 勾选Yes Configuration 实在Xcode中的配置，默认有Debug和Release，这里的AdHoc是我自己在项目中添加的配置。 这里设置 .ipa 文件的名称。其中 ${JOB_NAME} 为本项目Job的名字，${BUILD_ID}为本次构建的版本号。 这里设置构建过程输出目录。其中 ${WORKSPACE} 为jenkins 提供的系统变量，为构建根目录。 代码签名及密匙配置 本文采用在Xcode 项目中 共享scheme 的方式，在 scheme 内部对代码签名和 Profile 做好了配置，同时 jenkins 所在的 Mac OSX 中有对应的证书和Profile，所以 1 中不需要做特殊配置，如果配置，将替换scheme中的配置。 在打包过程中，命令会由于系统的安全设置提醒输入密码，2中可以设置密匙所在路径及系统用户密码。 Keychain path ：${HOME}/Library/Keychains/login.keychain 为系统登录密匙路径。 Keychain password ： 填入电脑的用户密码。 【注】：Xcode中共享 scheme 的 方法 后边会说到。 Xcode高级构建配置 这里的Project就是我在Xcode项目中共享的scheme。 本文中的项目中包含有workspace，这里设置对应路径，不需要带上 .xcworkspace后缀。 Xcode项目所在目录。 Xcode项目文件路径，这里需要带上 .xcodeproj 后缀。 设置构建输出目录。 发布到fir.im新增一个 构建后操作步骤 这里添加 fir.im Token 从自己的fir.im账号里获取 启动构建 到这里自动构建就完成了 下面来说下共享Xcode项目中scheme “+” 可以新建scheme 将共享后的scheme 纳入版本管理后，就可以用按上边的步骤配置好的jenkins 来自动构建了。","categories":[{"name":"Xcode","slug":"Xcode","permalink":"http://yoursite.com/categories/Xcode/"}],"tags":[{"name":"CI","slug":"CI","permalink":"http://yoursite.com/tags/CI/"}]}]}